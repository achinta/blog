{
  
    
        "post0": {
            "title": "Understanding the python data model",
            "content": "class MyMath(object): def add(self, a, b): return a + b print(f&#39;identiy of class - {id(MyMath)}&#39;) math = MyMath() print(f&#39;identity of object - {id(math)}&#39;) # lets create another object math2 = MyMath() # check math is math2 print(f&#39;id of 3 is {id(3)}&#39;) print(f&#39;id of None is {id(None)}&#39;) . identiy of class - 140253866597016 identity of object - 4514956064 id of 3 is 4475962864 id of None is 4475682680 . 3.1.2 type . type() function return an objects type (which is also an object). . Types affect almost all aspects of object behaviour Even the importance of object identity is affected in some sense: for immutable types, operations that compute new values may actually return a reference to any existing object with same type and value, while for mutable objects it is not allowed. . print(f&#39;id of returned value 5 is {id(math.add(2,3))}&#39;) print(f&#39;id of returned value 5 is {id(math.add(3,2))}&#39;) print(f&#39;id 5 is {id(5)}&#39;) . id of returned value 5 is 4475962928 id of returned value 5 is 4475962928 id 5 is 4475962928 . So we are referring to the same memory location when we refer to 5 during these three lines. . 3.1.3 value . The value of some objects can change. An objects mutability is determined by its type. . mutable - numbers, strings, tuples | immutable - Dictionaries, lists | . 3.2 The standard type hierarchy . Not covering everything here. . Bytes . A bytes object is an immutable array. The items are 8-bit bytes, represented by integers in the range 0 &lt;= x &lt; 256. Bytes literals (like b&#39;abc&#39;) and the built-in bytes() constructor can be used to create bytes objects. Also, bytes objects can be decoded to strings via the decode() method. . Byte Arrays . It is an mutable array, created by bytearray() constructor. Otherwise, they provide the same interface and functionality as the immutable bytes object. . Callable Types . user-defined functions . Note that many of these function object attributes are writable (check the link) . def add(a, b=3): return a + b attrs = [&#39;__name__&#39;, &#39;__qualname__&#39;, &#39;__module__&#39;, &#39;__defaults__&#39;, &#39;__code__&#39;, &#39;__dict__&#39;, &#39;__annotations__&#39;, &#39;__kwdefaults__&#39;] for attr in attrs: print(f&#39;{attr} - {getattr(add, attr)}&#39;) . __name__ - add __qualname__ - add __module__ - __main__ __defaults__ - (3,) __code__ - &lt;code object add at 0x10d1aeed0, file &#34;&lt;ipython-input-59-9d81faad02a5&gt;&#34;, line 1&gt; __dict__ - {} __annotations__ - {} __kwdefaults__ - None . The list of all attributes of a function object can be seen using dir(method) . The function objects also support getting and setting of arbitrary attributes, which can be used, for example, to attach metadata to functions. . add.newattr = &#39;this is a new attr&#39; print(f&#39;new attribute added is - {add.newattr}&#39;) . new attribute added is - this is a new attr . Instance methods have additional attributs like self We can read, but not set arbitrary function attributes. . MyMath.add(math, 2,1) . 3 .",
            "url": "https://achinta.github.io/blog/2020/10/17/python-data-model.html",
            "relUrl": "/2020/10/17/python-data-model.html",
            "date": " • Oct 17, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Cuda 11 Installation On Centos 8",
            "content": "Here I will describe the steps I followed to install cuda 11.1 on a fresh Centos 8 server. This involves three steps. . 1. Installing Nvidia driver . . . # Install development tools which include gcc and make sudo dnf group install &quot;Development Tools&quot; sudo yum install elfutils-libelf-devel # install libelf yum install elfutils-libelf-devel # install dkms sudo yum install epel-release -y sudo yum install dkms -y # install the driver sudo bash NVIDIA-Linux-x86_64-450.80.02.run . 2. Install cuda . Download cuda from https://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;target_arch=x86_64&amp;target_distro=CentOS&amp;target_version=8&amp;target_type=rpmlocal Follow the commands given on the page. For me, it was . wget https://developer.download.nvidia.com/compute/cuda/11.1.0/local_installers/cuda-repo-rhel8-11-1-local-11.1.0_455.23.05-1.x86_64.rpm sudo rpm -i cuda-repo-rhel8-11-1-local-11.1.0_455.23.05-1.x86_64.rpm sudo dnf clean all sudo dnf -y module install nvidia-driver:latest-dkms sudo dnf -y install cuda # verify the cuda version nvidia-smi . 3. Install cudnn . To download cudnn, we need to login to nvidia website, which is not possible on the server. So I did it locally and copied the files to server. . sudo rpm -ivh libcudnn8-8.0.4.30-1.cuda11.1.x86_64.rpm sudo rpm -ivh libcudnn8-devel-8.0.4.30-1.cuda11.1.x86_64.rpm .",
            "url": "https://achinta.github.io/blog/2020/10/05/cuda-11-installation-on-centos-8.html",
            "relUrl": "/2020/10/05/cuda-11-installation-on-centos-8.html",
            "date": " • Oct 5, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://achinta.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://achinta.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}